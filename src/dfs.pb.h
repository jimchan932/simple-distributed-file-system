// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dfs.proto

#ifndef PROTOBUF_INCLUDED_dfs_2eproto
#define PROTOBUF_INCLUDED_dfs_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_dfs_2eproto 

namespace protobuf_dfs_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_dfs_2eproto
namespace dfs {
class ClientAddress;
class ClientAddressDefaultTypeInternal;
extern ClientAddressDefaultTypeInternal _ClientAddress_default_instance_;
class ClientID;
class ClientIDDefaultTypeInternal;
extern ClientIDDefaultTypeInternal _ClientID_default_instance_;
class DirectoryPath;
class DirectoryPathDefaultTypeInternal;
extern DirectoryPathDefaultTypeInternal _DirectoryPath_default_instance_;
class FileHandle;
class FileHandleDefaultTypeInternal;
extern FileHandleDefaultTypeInternal _FileHandle_default_instance_;
class FileList;
class FileListDefaultTypeInternal;
extern FileListDefaultTypeInternal _FileList_default_instance_;
class FileRequest;
class FileRequestDefaultTypeInternal;
extern FileRequestDefaultTypeInternal _FileRequest_default_instance_;
class Filename;
class FilenameDefaultTypeInternal;
extern FilenameDefaultTypeInternal _Filename_default_instance_;
class Invalidation;
class InvalidationDefaultTypeInternal;
extern InvalidationDefaultTypeInternal _Invalidation_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
}  // namespace dfs
namespace google {
namespace protobuf {
template<> ::dfs::ClientAddress* Arena::CreateMaybeMessage<::dfs::ClientAddress>(Arena*);
template<> ::dfs::ClientID* Arena::CreateMaybeMessage<::dfs::ClientID>(Arena*);
template<> ::dfs::DirectoryPath* Arena::CreateMaybeMessage<::dfs::DirectoryPath>(Arena*);
template<> ::dfs::FileHandle* Arena::CreateMaybeMessage<::dfs::FileHandle>(Arena*);
template<> ::dfs::FileList* Arena::CreateMaybeMessage<::dfs::FileList>(Arena*);
template<> ::dfs::FileRequest* Arena::CreateMaybeMessage<::dfs::FileRequest>(Arena*);
template<> ::dfs::Filename* Arena::CreateMaybeMessage<::dfs::Filename>(Arena*);
template<> ::dfs::Invalidation* Arena::CreateMaybeMessage<::dfs::Invalidation>(Arena*);
template<> ::dfs::Response* Arena::CreateMaybeMessage<::dfs::Response>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace dfs {

// ===================================================================

class FileList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dfs.FileList) */ {
 public:
  FileList();
  virtual ~FileList();

  FileList(const FileList& from);

  inline FileList& operator=(const FileList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileList(FileList&& from) noexcept
    : FileList() {
    *this = ::std::move(from);
  }

  inline FileList& operator=(FileList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FileList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileList* internal_default_instance() {
    return reinterpret_cast<const FileList*>(
               &_FileList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(FileList* other);
  friend void swap(FileList& a, FileList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileList* New() const final {
    return CreateMaybeMessage<FileList>(NULL);
  }

  FileList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileList& from);
  void MergeFrom(const FileList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string filelist = 1;
  void clear_filelist();
  static const int kFilelistFieldNumber = 1;
  const ::std::string& filelist() const;
  void set_filelist(const ::std::string& value);
  #if LANG_CXX11
  void set_filelist(::std::string&& value);
  #endif
  void set_filelist(const char* value);
  void set_filelist(const char* value, size_t size);
  ::std::string* mutable_filelist();
  ::std::string* release_filelist();
  void set_allocated_filelist(::std::string* filelist);

  // @@protoc_insertion_point(class_scope:dfs.FileList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr filelist_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dfs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FileRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dfs.FileRequest) */ {
 public:
  FileRequest();
  virtual ~FileRequest();

  FileRequest(const FileRequest& from);

  inline FileRequest& operator=(const FileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileRequest(FileRequest&& from) noexcept
    : FileRequest() {
    *this = ::std::move(from);
  }

  inline FileRequest& operator=(FileRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FileRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileRequest* internal_default_instance() {
    return reinterpret_cast<const FileRequest*>(
               &_FileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(FileRequest* other);
  friend void swap(FileRequest& a, FileRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileRequest* New() const final {
    return CreateMaybeMessage<FileRequest>(NULL);
  }

  FileRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileRequest& from);
  void MergeFrom(const FileRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string fname = 2;
  void clear_fname();
  static const int kFnameFieldNumber = 2;
  const ::std::string& fname() const;
  void set_fname(const ::std::string& value);
  #if LANG_CXX11
  void set_fname(::std::string&& value);
  #endif
  void set_fname(const char* value);
  void set_fname(const char* value, size_t size);
  ::std::string* mutable_fname();
  ::std::string* release_fname();
  void set_allocated_fname(::std::string* fname);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:dfs.FileRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr fname_;
  ::google::protobuf::int32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dfs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dfs.ClientID) */ {
 public:
  ClientID();
  virtual ~ClientID();

  ClientID(const ClientID& from);

  inline ClientID& operator=(const ClientID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientID(ClientID&& from) noexcept
    : ClientID() {
    *this = ::std::move(from);
  }

  inline ClientID& operator=(ClientID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientID* internal_default_instance() {
    return reinterpret_cast<const ClientID*>(
               &_ClientID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ClientID* other);
  friend void swap(ClientID& a, ClientID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientID* New() const final {
    return CreateMaybeMessage<ClientID>(NULL);
  }

  ClientID* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientID>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientID& from);
  void MergeFrom(const ClientID& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:dfs.ClientID)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dfs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Invalidation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dfs.Invalidation) */ {
 public:
  Invalidation();
  virtual ~Invalidation();

  Invalidation(const Invalidation& from);

  inline Invalidation& operator=(const Invalidation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Invalidation(Invalidation&& from) noexcept
    : Invalidation() {
    *this = ::std::move(from);
  }

  inline Invalidation& operator=(Invalidation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Invalidation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Invalidation* internal_default_instance() {
    return reinterpret_cast<const Invalidation*>(
               &_Invalidation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Invalidation* other);
  friend void swap(Invalidation& a, Invalidation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Invalidation* New() const final {
    return CreateMaybeMessage<Invalidation>(NULL);
  }

  Invalidation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Invalidation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Invalidation& from);
  void MergeFrom(const Invalidation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Invalidation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 is_valid = 1;
  void clear_is_valid();
  static const int kIsValidFieldNumber = 1;
  ::google::protobuf::int32 is_valid() const;
  void set_is_valid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:dfs.Invalidation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 is_valid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dfs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dfs.Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Response* other);
  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const final {
    return CreateMaybeMessage<Response>(NULL);
  }

  Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 success = 1;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  ::google::protobuf::int32 success() const;
  void set_success(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:dfs.Response)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 success_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dfs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Filename : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dfs.Filename) */ {
 public:
  Filename();
  virtual ~Filename();

  Filename(const Filename& from);

  inline Filename& operator=(const Filename& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Filename(Filename&& from) noexcept
    : Filename() {
    *this = ::std::move(from);
  }

  inline Filename& operator=(Filename&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Filename& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Filename* internal_default_instance() {
    return reinterpret_cast<const Filename*>(
               &_Filename_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Filename* other);
  friend void swap(Filename& a, Filename& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Filename* New() const final {
    return CreateMaybeMessage<Filename>(NULL);
  }

  Filename* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Filename>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Filename& from);
  void MergeFrom(const Filename& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Filename* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string fname = 1;
  void clear_fname();
  static const int kFnameFieldNumber = 1;
  const ::std::string& fname() const;
  void set_fname(const ::std::string& value);
  #if LANG_CXX11
  void set_fname(::std::string&& value);
  #endif
  void set_fname(const char* value);
  void set_fname(const char* value, size_t size);
  ::std::string* mutable_fname();
  ::std::string* release_fname();
  void set_allocated_fname(::std::string* fname);

  // @@protoc_insertion_point(class_scope:dfs.Filename)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr fname_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dfs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FileHandle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dfs.FileHandle) */ {
 public:
  FileHandle();
  virtual ~FileHandle();

  FileHandle(const FileHandle& from);

  inline FileHandle& operator=(const FileHandle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileHandle(FileHandle&& from) noexcept
    : FileHandle() {
    *this = ::std::move(from);
  }

  inline FileHandle& operator=(FileHandle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FileHandle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileHandle* internal_default_instance() {
    return reinterpret_cast<const FileHandle*>(
               &_FileHandle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(FileHandle* other);
  friend void swap(FileHandle& a, FileHandle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileHandle* New() const final {
    return CreateMaybeMessage<FileHandle>(NULL);
  }

  FileHandle* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileHandle>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileHandle& from);
  void MergeFrom(const FileHandle& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileHandle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string fname = 1;
  void clear_fname();
  static const int kFnameFieldNumber = 1;
  const ::std::string& fname() const;
  void set_fname(const ::std::string& value);
  #if LANG_CXX11
  void set_fname(::std::string&& value);
  #endif
  void set_fname(const char* value);
  void set_fname(const char* value, size_t size);
  ::std::string* mutable_fname();
  ::std::string* release_fname();
  void set_allocated_fname(::std::string* fname);

  // string buffer = 2;
  void clear_buffer();
  static const int kBufferFieldNumber = 2;
  const ::std::string& buffer() const;
  void set_buffer(const ::std::string& value);
  #if LANG_CXX11
  void set_buffer(::std::string&& value);
  #endif
  void set_buffer(const char* value);
  void set_buffer(const char* value, size_t size);
  ::std::string* mutable_buffer();
  ::std::string* release_buffer();
  void set_allocated_buffer(::std::string* buffer);

  // int32 access = 3;
  void clear_access();
  static const int kAccessFieldNumber = 3;
  ::google::protobuf::int32 access() const;
  void set_access(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:dfs.FileHandle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr fname_;
  ::google::protobuf::internal::ArenaStringPtr buffer_;
  ::google::protobuf::int32 access_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dfs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientAddress : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dfs.ClientAddress) */ {
 public:
  ClientAddress();
  virtual ~ClientAddress();

  ClientAddress(const ClientAddress& from);

  inline ClientAddress& operator=(const ClientAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientAddress(ClientAddress&& from) noexcept
    : ClientAddress() {
    *this = ::std::move(from);
  }

  inline ClientAddress& operator=(ClientAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientAddress* internal_default_instance() {
    return reinterpret_cast<const ClientAddress*>(
               &_ClientAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ClientAddress* other);
  friend void swap(ClientAddress& a, ClientAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientAddress* New() const final {
    return CreateMaybeMessage<ClientAddress>(NULL);
  }

  ClientAddress* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientAddress>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientAddress& from);
  void MergeFrom(const ClientAddress& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ip_address = 1;
  void clear_ip_address();
  static const int kIpAddressFieldNumber = 1;
  const ::std::string& ip_address() const;
  void set_ip_address(const ::std::string& value);
  #if LANG_CXX11
  void set_ip_address(::std::string&& value);
  #endif
  void set_ip_address(const char* value);
  void set_ip_address(const char* value, size_t size);
  ::std::string* mutable_ip_address();
  ::std::string* release_ip_address();
  void set_allocated_ip_address(::std::string* ip_address);

  // int32 port = 2;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:dfs.ClientAddress)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ip_address_;
  ::google::protobuf::int32 port_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dfs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DirectoryPath : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dfs.DirectoryPath) */ {
 public:
  DirectoryPath();
  virtual ~DirectoryPath();

  DirectoryPath(const DirectoryPath& from);

  inline DirectoryPath& operator=(const DirectoryPath& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DirectoryPath(DirectoryPath&& from) noexcept
    : DirectoryPath() {
    *this = ::std::move(from);
  }

  inline DirectoryPath& operator=(DirectoryPath&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectoryPath& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectoryPath* internal_default_instance() {
    return reinterpret_cast<const DirectoryPath*>(
               &_DirectoryPath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(DirectoryPath* other);
  friend void swap(DirectoryPath& a, DirectoryPath& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DirectoryPath* New() const final {
    return CreateMaybeMessage<DirectoryPath>(NULL);
  }

  DirectoryPath* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DirectoryPath>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DirectoryPath& from);
  void MergeFrom(const DirectoryPath& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirectoryPath* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 1;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:dfs.DirectoryPath)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dfs_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FileList

// string filelist = 1;
inline void FileList::clear_filelist() {
  filelist_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileList::filelist() const {
  // @@protoc_insertion_point(field_get:dfs.FileList.filelist)
  return filelist_.GetNoArena();
}
inline void FileList::set_filelist(const ::std::string& value) {
  
  filelist_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dfs.FileList.filelist)
}
#if LANG_CXX11
inline void FileList::set_filelist(::std::string&& value) {
  
  filelist_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dfs.FileList.filelist)
}
#endif
inline void FileList::set_filelist(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  filelist_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dfs.FileList.filelist)
}
inline void FileList::set_filelist(const char* value, size_t size) {
  
  filelist_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dfs.FileList.filelist)
}
inline ::std::string* FileList::mutable_filelist() {
  
  // @@protoc_insertion_point(field_mutable:dfs.FileList.filelist)
  return filelist_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileList::release_filelist() {
  // @@protoc_insertion_point(field_release:dfs.FileList.filelist)
  
  return filelist_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileList::set_allocated_filelist(::std::string* filelist) {
  if (filelist != NULL) {
    
  } else {
    
  }
  filelist_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filelist);
  // @@protoc_insertion_point(field_set_allocated:dfs.FileList.filelist)
}

// -------------------------------------------------------------------

// FileRequest

// int32 id = 1;
inline void FileRequest::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 FileRequest::id() const {
  // @@protoc_insertion_point(field_get:dfs.FileRequest.id)
  return id_;
}
inline void FileRequest::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:dfs.FileRequest.id)
}

// string fname = 2;
inline void FileRequest::clear_fname() {
  fname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileRequest::fname() const {
  // @@protoc_insertion_point(field_get:dfs.FileRequest.fname)
  return fname_.GetNoArena();
}
inline void FileRequest::set_fname(const ::std::string& value) {
  
  fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dfs.FileRequest.fname)
}
#if LANG_CXX11
inline void FileRequest::set_fname(::std::string&& value) {
  
  fname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dfs.FileRequest.fname)
}
#endif
inline void FileRequest::set_fname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dfs.FileRequest.fname)
}
inline void FileRequest::set_fname(const char* value, size_t size) {
  
  fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dfs.FileRequest.fname)
}
inline ::std::string* FileRequest::mutable_fname() {
  
  // @@protoc_insertion_point(field_mutable:dfs.FileRequest.fname)
  return fname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileRequest::release_fname() {
  // @@protoc_insertion_point(field_release:dfs.FileRequest.fname)
  
  return fname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileRequest::set_allocated_fname(::std::string* fname) {
  if (fname != NULL) {
    
  } else {
    
  }
  fname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fname);
  // @@protoc_insertion_point(field_set_allocated:dfs.FileRequest.fname)
}

// -------------------------------------------------------------------

// ClientID

// int32 id = 1;
inline void ClientID::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 ClientID::id() const {
  // @@protoc_insertion_point(field_get:dfs.ClientID.id)
  return id_;
}
inline void ClientID::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:dfs.ClientID.id)
}

// -------------------------------------------------------------------

// Invalidation

// int32 is_valid = 1;
inline void Invalidation::clear_is_valid() {
  is_valid_ = 0;
}
inline ::google::protobuf::int32 Invalidation::is_valid() const {
  // @@protoc_insertion_point(field_get:dfs.Invalidation.is_valid)
  return is_valid_;
}
inline void Invalidation::set_is_valid(::google::protobuf::int32 value) {
  
  is_valid_ = value;
  // @@protoc_insertion_point(field_set:dfs.Invalidation.is_valid)
}

// -------------------------------------------------------------------

// Response

// int32 success = 1;
inline void Response::clear_success() {
  success_ = 0;
}
inline ::google::protobuf::int32 Response::success() const {
  // @@protoc_insertion_point(field_get:dfs.Response.success)
  return success_;
}
inline void Response::set_success(::google::protobuf::int32 value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:dfs.Response.success)
}

// -------------------------------------------------------------------

// Filename

// string fname = 1;
inline void Filename::clear_fname() {
  fname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Filename::fname() const {
  // @@protoc_insertion_point(field_get:dfs.Filename.fname)
  return fname_.GetNoArena();
}
inline void Filename::set_fname(const ::std::string& value) {
  
  fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dfs.Filename.fname)
}
#if LANG_CXX11
inline void Filename::set_fname(::std::string&& value) {
  
  fname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dfs.Filename.fname)
}
#endif
inline void Filename::set_fname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dfs.Filename.fname)
}
inline void Filename::set_fname(const char* value, size_t size) {
  
  fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dfs.Filename.fname)
}
inline ::std::string* Filename::mutable_fname() {
  
  // @@protoc_insertion_point(field_mutable:dfs.Filename.fname)
  return fname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Filename::release_fname() {
  // @@protoc_insertion_point(field_release:dfs.Filename.fname)
  
  return fname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Filename::set_allocated_fname(::std::string* fname) {
  if (fname != NULL) {
    
  } else {
    
  }
  fname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fname);
  // @@protoc_insertion_point(field_set_allocated:dfs.Filename.fname)
}

// -------------------------------------------------------------------

// FileHandle

// string fname = 1;
inline void FileHandle::clear_fname() {
  fname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileHandle::fname() const {
  // @@protoc_insertion_point(field_get:dfs.FileHandle.fname)
  return fname_.GetNoArena();
}
inline void FileHandle::set_fname(const ::std::string& value) {
  
  fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dfs.FileHandle.fname)
}
#if LANG_CXX11
inline void FileHandle::set_fname(::std::string&& value) {
  
  fname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dfs.FileHandle.fname)
}
#endif
inline void FileHandle::set_fname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dfs.FileHandle.fname)
}
inline void FileHandle::set_fname(const char* value, size_t size) {
  
  fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dfs.FileHandle.fname)
}
inline ::std::string* FileHandle::mutable_fname() {
  
  // @@protoc_insertion_point(field_mutable:dfs.FileHandle.fname)
  return fname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileHandle::release_fname() {
  // @@protoc_insertion_point(field_release:dfs.FileHandle.fname)
  
  return fname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileHandle::set_allocated_fname(::std::string* fname) {
  if (fname != NULL) {
    
  } else {
    
  }
  fname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fname);
  // @@protoc_insertion_point(field_set_allocated:dfs.FileHandle.fname)
}

// string buffer = 2;
inline void FileHandle::clear_buffer() {
  buffer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileHandle::buffer() const {
  // @@protoc_insertion_point(field_get:dfs.FileHandle.buffer)
  return buffer_.GetNoArena();
}
inline void FileHandle::set_buffer(const ::std::string& value) {
  
  buffer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dfs.FileHandle.buffer)
}
#if LANG_CXX11
inline void FileHandle::set_buffer(::std::string&& value) {
  
  buffer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dfs.FileHandle.buffer)
}
#endif
inline void FileHandle::set_buffer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  buffer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dfs.FileHandle.buffer)
}
inline void FileHandle::set_buffer(const char* value, size_t size) {
  
  buffer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dfs.FileHandle.buffer)
}
inline ::std::string* FileHandle::mutable_buffer() {
  
  // @@protoc_insertion_point(field_mutable:dfs.FileHandle.buffer)
  return buffer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileHandle::release_buffer() {
  // @@protoc_insertion_point(field_release:dfs.FileHandle.buffer)
  
  return buffer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileHandle::set_allocated_buffer(::std::string* buffer) {
  if (buffer != NULL) {
    
  } else {
    
  }
  buffer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), buffer);
  // @@protoc_insertion_point(field_set_allocated:dfs.FileHandle.buffer)
}

// int32 access = 3;
inline void FileHandle::clear_access() {
  access_ = 0;
}
inline ::google::protobuf::int32 FileHandle::access() const {
  // @@protoc_insertion_point(field_get:dfs.FileHandle.access)
  return access_;
}
inline void FileHandle::set_access(::google::protobuf::int32 value) {
  
  access_ = value;
  // @@protoc_insertion_point(field_set:dfs.FileHandle.access)
}

// -------------------------------------------------------------------

// ClientAddress

// string ip_address = 1;
inline void ClientAddress::clear_ip_address() {
  ip_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientAddress::ip_address() const {
  // @@protoc_insertion_point(field_get:dfs.ClientAddress.ip_address)
  return ip_address_.GetNoArena();
}
inline void ClientAddress::set_ip_address(const ::std::string& value) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dfs.ClientAddress.ip_address)
}
#if LANG_CXX11
inline void ClientAddress::set_ip_address(::std::string&& value) {
  
  ip_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dfs.ClientAddress.ip_address)
}
#endif
inline void ClientAddress::set_ip_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dfs.ClientAddress.ip_address)
}
inline void ClientAddress::set_ip_address(const char* value, size_t size) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dfs.ClientAddress.ip_address)
}
inline ::std::string* ClientAddress::mutable_ip_address() {
  
  // @@protoc_insertion_point(field_mutable:dfs.ClientAddress.ip_address)
  return ip_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientAddress::release_ip_address() {
  // @@protoc_insertion_point(field_release:dfs.ClientAddress.ip_address)
  
  return ip_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientAddress::set_allocated_ip_address(::std::string* ip_address) {
  if (ip_address != NULL) {
    
  } else {
    
  }
  ip_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip_address);
  // @@protoc_insertion_point(field_set_allocated:dfs.ClientAddress.ip_address)
}

// int32 port = 2;
inline void ClientAddress::clear_port() {
  port_ = 0;
}
inline ::google::protobuf::int32 ClientAddress::port() const {
  // @@protoc_insertion_point(field_get:dfs.ClientAddress.port)
  return port_;
}
inline void ClientAddress::set_port(::google::protobuf::int32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:dfs.ClientAddress.port)
}

// -------------------------------------------------------------------

// DirectoryPath

// string path = 1;
inline void DirectoryPath::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DirectoryPath::path() const {
  // @@protoc_insertion_point(field_get:dfs.DirectoryPath.path)
  return path_.GetNoArena();
}
inline void DirectoryPath::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dfs.DirectoryPath.path)
}
#if LANG_CXX11
inline void DirectoryPath::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dfs.DirectoryPath.path)
}
#endif
inline void DirectoryPath::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dfs.DirectoryPath.path)
}
inline void DirectoryPath::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dfs.DirectoryPath.path)
}
inline ::std::string* DirectoryPath::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:dfs.DirectoryPath.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectoryPath::release_path() {
  // @@protoc_insertion_point(field_release:dfs.DirectoryPath.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectoryPath::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:dfs.DirectoryPath.path)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace dfs

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_dfs_2eproto
